# RAG Service SQL Parameter Binding Fix

## Problem

The `_hybrid_search` method in `app/services/rag_service.py` needed to properly bind SQL parameters when using SQLAlchemy with asyncpg. The correct approach is to use SQLAlchemy's named parameter syntax (`:param_name`) with a dictionary, not positional parameters.

## Solution

The fix uses two approaches for different types of parameters:

### 1. Safe Direct Interpolation (for non-user input)
- **Embedding vector**: Interpolated directly using f-string (safe - generated internally by embedding service)
- **Chapter ID**: Interpolated directly using f-string (safe - UUID from our system, not user input)

### 2. Named Parameters (for user input and numeric values)
- **Query string**: Uses `:query` named parameter
- **Weights and limit**: Uses `:semantic_weight`, `:keyword_weight`, `:limit` named parameters
- **Parameters passed as dictionary** to `execute()`

## Implementation

```python
# Convert embedding to PostgreSQL vector format
embedding_str = "[" + ",".join(map(str, query_embedding)) + "]"

# Build chapter filter
if chapter_id:
    chapter_filter_sql = f"AND c.chapter_id = '{str(chapter_id)}'"
else:
    chapter_filter_sql = ""

# Build SQL with f-string interpolation for safe values and named params for others
query_sql = text(f"""
    WITH semantic_scores AS (
        SELECT
            ...
            1 - (c.embedding <=> '{embedding_str}'::vector) as semantic_score
        FROM chunks c
        WHERE true {chapter_filter_sql}
    ),
    keyword_scores AS (
        SELECT
            c.id,
            ts_rank(c.content_tsv, websearch_to_tsquery('english', :query)) as keyword_score
        FROM chunks c
        WHERE c.content_tsv @@ websearch_to_tsquery('english', :query)
            {chapter_filter_sql}
    ),
    combined AS (
        SELECT
            ...
            (:semantic_weight * s.semantic_score +
             :keyword_weight * COALESCE(k.keyword_score, 0.0)) as combined_score
        ...
    )
    ...
    LIMIT :limit
""")

# Execute with named parameters (dictionary)
result = await self.session.execute(
    query_sql,
    {
        "query": query,
        "semantic_weight": self.semantic_weight,
        "keyword_weight": self.keyword_weight,
        "limit": limit
    }
)
```

## Security Considerations

### Safe to Interpolate (f-string)
- **Embedding vector**: Generated by OpenAI API, contains only floats - no SQL injection risk
- **Chapter ID**: UUID type from our database, validated internally - no user input

### Requires Named Parameter Binding
- **User query string**: Direct user input, MUST use named parameters to prevent SQL injection
- **Numeric parameters**: While not directly from user input, using named params is the SQLAlchemy standard

## Why Named Parameters?

SQLAlchemy with asyncpg requires:
- **Named parameters** (`:param_name`) in the SQL query
- **Dictionary** of parameter values passed to `execute()`

Positional parameters (`$1`, `$2`) are a PostgreSQL/asyncpg feature but not how SQLAlchemy's text() construct works with asyncpg.

## Testing

Created `tests/test_rag_sql_syntax.py` to verify:
1. SQL compiles without syntax errors
2. Named parameters are present in the query text
3. Works with chapter filter
4. Works without chapter filter

All tests pass âœ“

## Benefits

1. **Correct SQLAlchemy Usage**: Uses named parameters as SQLAlchemy expects
2. **Secure**: User input properly parameterized against SQL injection
3. **Performant**: Direct interpolation for safe internal values (embedding, chapter_id)
4. **Maintainable**: Clear separation between safe interpolation and parameter binding

## Migration Notes

No database migrations required - this is purely a code fix for query execution.
